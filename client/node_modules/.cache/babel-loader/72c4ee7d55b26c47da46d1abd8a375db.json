{"ast":null,"code":"'use strict';\n\nvar Map = require('./map'),\n    Long = require('./long'),\n    Double = require('./double'),\n    Timestamp = require('./timestamp'),\n    ObjectID = require('./objectid'),\n    BSONRegExp = require('./regexp'),\n    Symbol = require('./symbol'),\n    Int32 = require('./int_32'),\n    Code = require('./code'),\n    Decimal128 = require('./decimal128'),\n    MinKey = require('./min_key'),\n    MaxKey = require('./max_key'),\n    DBRef = require('./db_ref'),\n    Binary = require('./binary'); // Parts of the parser\n\n\nvar deserialize = require('./parser/deserializer'),\n    serializer = require('./parser/serializer'),\n    calculateObjectSize = require('./parser/calculate_size'),\n    utils = require('./parser/utils');\n/**\n * @ignore\n * @api private\n */\n// Default Max Size\n\n\nvar MAXSIZE = 1024 * 1024 * 17; // Current Internal Temporary Serialization Buffer\n\nvar buffer = utils.allocBuffer(MAXSIZE);\n\nvar BSON = function BSON() {};\n/**\n * Serialize a Javascript object.\n *\n * @param {Object} object the Javascript object to serialize.\n * @param {Boolean} [options.checkKeys] the serializer will check if keys are valid.\n * @param {Boolean} [options.serializeFunctions=false] serialize the javascript functions **(default:false)**.\n * @param {Boolean} [options.ignoreUndefined=true] ignore undefined fields **(default:true)**.\n * @param {Number} [options.minInternalBufferSize=1024*1024*17] minimum size of the internal temporary serialization buffer **(default:1024*1024*17)**.\n * @return {Buffer} returns the Buffer object containing the serialized object.\n * @api public\n */\n\n\nBSON.prototype.serialize = function serialize(object, options) {\n  options = options || {}; // Unpack the options\n\n  var checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n  var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n  var minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE; // Resize the internal serialization buffer if needed\n\n  if (buffer.length < minInternalBufferSize) {\n    buffer = utils.allocBuffer(minInternalBufferSize);\n  } // Attempt to serialize\n\n\n  var serializationIndex = serializer(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []); // Create the final buffer\n\n  var finishedBuffer = utils.allocBuffer(serializationIndex); // Copy into the finished buffer\n\n  buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length); // Return the buffer\n\n  return finishedBuffer;\n};\n/**\n * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.\n *\n * @param {Object} object the Javascript object to serialize.\n * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.\n * @param {Boolean} [options.checkKeys] the serializer will check if keys are valid.\n * @param {Boolean} [options.serializeFunctions=false] serialize the javascript functions **(default:false)**.\n * @param {Boolean} [options.ignoreUndefined=true] ignore undefined fields **(default:true)**.\n * @param {Number} [options.index] the index in the buffer where we wish to start serializing into.\n * @return {Number} returns the index pointing to the last written byte in the buffer.\n * @api public\n */\n\n\nBSON.prototype.serializeWithBufferAndIndex = function (object, finalBuffer, options) {\n  options = options || {}; // Unpack the options\n\n  var checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n  var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n  var startIndex = typeof options.index === 'number' ? options.index : 0; // Attempt to serialize\n\n  var serializationIndex = serializer(finalBuffer, object, checkKeys, startIndex || 0, 0, serializeFunctions, ignoreUndefined); // Return the index\n\n  return serializationIndex - 1;\n};\n/**\n * Deserialize data as BSON.\n *\n * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.\n * @param {Object} [options.evalFunctions=false] evaluate functions in the BSON document scoped to the object deserialized.\n * @param {Object} [options.cacheFunctions=false] cache evaluated functions for reuse.\n * @param {Object} [options.cacheFunctionsCrc32=false] use a crc32 code for caching, otherwise use the string of the function.\n * @param {Object} [options.promoteLongs=true] when deserializing a Long will fit it into a Number if it's smaller than 53 bits\n * @param {Object} [options.promoteBuffers=false] when deserializing a Binary will return it as a node.js Buffer instance.\n * @param {Object} [options.promoteValues=false] when deserializing will promote BSON values to their Node.js closest equivalent types.\n * @param {Object} [options.fieldsAsRaw=null] allow to specify if there what fields we wish to return as unserialized raw buffer.\n * @param {Object} [options.bsonRegExp=false] return BSON regular expressions as BSONRegExp instances.\n * @return {Object} returns the deserialized Javascript Object.\n * @api public\n */\n\n\nBSON.prototype.deserialize = function (buffer, options) {\n  return deserialize(buffer, options);\n};\n/**\n * Calculate the bson size for a passed in Javascript object.\n *\n * @param {Object} object the Javascript object to calculate the BSON byte size for.\n * @param {Boolean} [options.serializeFunctions=false] serialize the javascript functions **(default:false)**.\n * @param {Boolean} [options.ignoreUndefined=true] ignore undefined fields **(default:true)**.\n * @return {Number} returns the number of bytes the BSON object will take up.\n * @api public\n */\n\n\nBSON.prototype.calculateObjectSize = function (object, options) {\n  options = options || {};\n  var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n  return calculateObjectSize(object, serializeFunctions, ignoreUndefined);\n};\n/**\n * Deserialize stream data as BSON documents.\n *\n * @param {Buffer} data the buffer containing the serialized set of BSON documents.\n * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.\n * @param {Number} numberOfDocuments number of documents to deserialize.\n * @param {Array} documents an array where to store the deserialized documents.\n * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.\n * @param {Object} [options] additional options used for the deserialization.\n * @param {Object} [options.evalFunctions=false] evaluate functions in the BSON document scoped to the object deserialized.\n * @param {Object} [options.cacheFunctions=false] cache evaluated functions for reuse.\n * @param {Object} [options.cacheFunctionsCrc32=false] use a crc32 code for caching, otherwise use the string of the function.\n * @param {Object} [options.promoteLongs=true] when deserializing a Long will fit it into a Number if it's smaller than 53 bits\n * @param {Object} [options.promoteBuffers=false] when deserializing a Binary will return it as a node.js Buffer instance.\n * @param {Object} [options.promoteValues=false] when deserializing will promote BSON values to their Node.js closest equivalent types.\n * @param {Object} [options.fieldsAsRaw=null] allow to specify if there what fields we wish to return as unserialized raw buffer.\n * @param {Object} [options.bsonRegExp=false] return BSON regular expressions as BSONRegExp instances.\n * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.\n * @api public\n */\n\n\nBSON.prototype.deserializeStream = function (data, startIndex, numberOfDocuments, documents, docStartIndex, options) {\n  options = options != null ? options : {};\n  var index = startIndex; // Loop over all documents\n\n  for (var i = 0; i < numberOfDocuments; i++) {\n    // Find size of the document\n    var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24; // Update options with index\n\n    options['index'] = index; // Parse the document at this point\n\n    documents[docStartIndex + i] = this.deserialize(data, options); // Adjust index by the document size\n\n    index = index + size;\n  } // Return object containing end index of parsing and list of documents\n\n\n  return index;\n};\n/**\n * @ignore\n * @api private\n */\n// BSON MAX VALUES\n\n\nBSON.BSON_INT32_MAX = 0x7fffffff;\nBSON.BSON_INT32_MIN = -0x80000000;\nBSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;\nBSON.BSON_INT64_MIN = -Math.pow(2, 63); // JS MAX PRECISE VALUES\n\nBSON.JS_INT_MAX = 0x20000000000000; // Any integer up to 2^53 can be precisely represented by a double.\n\nBSON.JS_INT_MIN = -0x20000000000000; // Any integer down to -2^53 can be precisely represented by a double.\n// Internal long versions\n// var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000); // Any integer up to 2^53 can be precisely represented by a double.\n// var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000); // Any integer down to -2^53 can be precisely represented by a double.\n\n/**\n * Number BSON Type\n *\n * @classconstant BSON_DATA_NUMBER\n **/\n\nBSON.BSON_DATA_NUMBER = 1;\n/**\n * String BSON Type\n *\n * @classconstant BSON_DATA_STRING\n **/\n\nBSON.BSON_DATA_STRING = 2;\n/**\n * Object BSON Type\n *\n * @classconstant BSON_DATA_OBJECT\n **/\n\nBSON.BSON_DATA_OBJECT = 3;\n/**\n * Array BSON Type\n *\n * @classconstant BSON_DATA_ARRAY\n **/\n\nBSON.BSON_DATA_ARRAY = 4;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_BINARY\n **/\n\nBSON.BSON_DATA_BINARY = 5;\n/**\n * ObjectID BSON Type\n *\n * @classconstant BSON_DATA_OID\n **/\n\nBSON.BSON_DATA_OID = 7;\n/**\n * Boolean BSON Type\n *\n * @classconstant BSON_DATA_BOOLEAN\n **/\n\nBSON.BSON_DATA_BOOLEAN = 8;\n/**\n * Date BSON Type\n *\n * @classconstant BSON_DATA_DATE\n **/\n\nBSON.BSON_DATA_DATE = 9;\n/**\n * null BSON Type\n *\n * @classconstant BSON_DATA_NULL\n **/\n\nBSON.BSON_DATA_NULL = 10;\n/**\n * RegExp BSON Type\n *\n * @classconstant BSON_DATA_REGEXP\n **/\n\nBSON.BSON_DATA_REGEXP = 11;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_CODE\n **/\n\nBSON.BSON_DATA_CODE = 13;\n/**\n * Symbol BSON Type\n *\n * @classconstant BSON_DATA_SYMBOL\n **/\n\nBSON.BSON_DATA_SYMBOL = 14;\n/**\n * Code with Scope BSON Type\n *\n * @classconstant BSON_DATA_CODE_W_SCOPE\n **/\n\nBSON.BSON_DATA_CODE_W_SCOPE = 15;\n/**\n * 32 bit Integer BSON Type\n *\n * @classconstant BSON_DATA_INT\n **/\n\nBSON.BSON_DATA_INT = 16;\n/**\n * Timestamp BSON Type\n *\n * @classconstant BSON_DATA_TIMESTAMP\n **/\n\nBSON.BSON_DATA_TIMESTAMP = 17;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_LONG\n **/\n\nBSON.BSON_DATA_LONG = 18;\n/**\n * MinKey BSON Type\n *\n * @classconstant BSON_DATA_MIN_KEY\n **/\n\nBSON.BSON_DATA_MIN_KEY = 0xff;\n/**\n * MaxKey BSON Type\n *\n * @classconstant BSON_DATA_MAX_KEY\n **/\n\nBSON.BSON_DATA_MAX_KEY = 0x7f;\n/**\n * Binary Default Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_DEFAULT\n **/\n\nBSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n/**\n * Binary Function Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_FUNCTION\n **/\n\nBSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;\n/**\n * Binary Byte Array Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY\n **/\n\nBSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\n/**\n * Binary UUID Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_UUID\n **/\n\nBSON.BSON_BINARY_SUBTYPE_UUID = 3;\n/**\n * Binary MD5 Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_MD5\n **/\n\nBSON.BSON_BINARY_SUBTYPE_MD5 = 4;\n/**\n * Binary User Defined Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED\n **/\n\nBSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128; // Return BSON\n\nmodule.exports = BSON;\nmodule.exports.Code = Code;\nmodule.exports.Map = Map;\nmodule.exports.Symbol = Symbol;\nmodule.exports.BSON = BSON;\nmodule.exports.DBRef = DBRef;\nmodule.exports.Binary = Binary;\nmodule.exports.ObjectID = ObjectID;\nmodule.exports.Long = Long;\nmodule.exports.Timestamp = Timestamp;\nmodule.exports.Double = Double;\nmodule.exports.Int32 = Int32;\nmodule.exports.MinKey = MinKey;\nmodule.exports.MaxKey = MaxKey;\nmodule.exports.BSONRegExp = BSONRegExp;\nmodule.exports.Decimal128 = Decimal128;","map":null,"metadata":{},"sourceType":"script"}