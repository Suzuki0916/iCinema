{"ast":null,"code":"'use strict'; // Load modules\n\nvar _classCallCheck = require(\"/Users/miladarif/Desktop/React/movie-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/miladarif/Desktop/React/movie-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Hoek = require('@hapi/hoek'); // Declare internals\n\n\nvar internals = {};\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function Topo() {\n    _classCallCheck(this, Topo);\n\n    this._items = [];\n    this.nodes = [];\n  }\n\n  _createClass(Topo, [{\n    key: \"add\",\n    value: function add(nodes, options) {\n      var _this = this;\n\n      options = options || {}; // Validate rules\n\n      var before = [].concat(options.before || []);\n      var after = [].concat(options.after || []);\n      var group = options.group || '?';\n      var sort = options.sort || 0; // Used for merging only\n\n      Hoek.assert(!before.includes(group), \"Item cannot come before itself: \".concat(group));\n      Hoek.assert(!before.includes('?'), 'Item cannot come before unassociated items');\n      Hoek.assert(!after.includes(group), \"Item cannot come after itself: \".concat(group));\n      Hoek.assert(!after.includes('?'), 'Item cannot come after unassociated items');\n      [].concat(nodes).forEach(function (node, i) {\n        var item = {\n          seq: _this._items.length,\n          sort: sort,\n          before: before,\n          after: after,\n          group: group,\n          node: node\n        };\n\n        _this._items.push(item);\n      }); // Insert event\n\n      var error = this._sort();\n\n      Hoek.assert(!error, 'item', group !== '?' ? \"added into group \".concat(group) : '', 'created a dependencies error');\n      return this.nodes;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(others) {\n      others = [].concat(others);\n\n      for (var i = 0; i < others.length; ++i) {\n        var other = others[i];\n\n        if (other) {\n          for (var j = 0; j < other._items.length; ++j) {\n            var item = Object.assign({}, other._items[j]); // Shallow cloned\n\n            this._items.push(item);\n          }\n        }\n      } // Sort items\n\n\n      this._items.sort(internals.mergeSort);\n\n      for (var _i = 0; _i < this._items.length; ++_i) {\n        this._items[_i].seq = _i;\n      }\n\n      var error = this._sort();\n\n      Hoek.assert(!error, 'merge created a dependencies error');\n      return this.nodes;\n    }\n  }, {\n    key: \"_sort\",\n    value: function _sort() {\n      // Construct graph\n      var graph = {};\n      var graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n\n      var groups = Object.create(null);\n\n      for (var i = 0; i < this._items.length; ++i) {\n        var item = this._items[i];\n        var seq = item.seq; // Unique across all items\n\n        var group = item.group; // Determine Groups\n\n        groups[group] = groups[group] || [];\n        groups[group].push(seq); // Build intermediary graph using 'before'\n\n        graph[seq] = item.before; // Build second intermediary graph with 'after'\n\n        var after = item.after;\n\n        for (var j = 0; j < after.length; ++j) {\n          graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);\n        }\n      } // Expand intermediary graph\n\n\n      var graphNodes = Object.keys(graph);\n\n      for (var _i2 = 0; _i2 < graphNodes.length; ++_i2) {\n        var node = graphNodes[_i2];\n        var expandedGroups = [];\n        var graphNodeItems = Object.keys(graph[node]);\n\n        for (var _j = 0; _j < graphNodeItems.length; ++_j) {\n          var _group = graph[node][graphNodeItems[_j]];\n          groups[_group] = groups[_group] || [];\n\n          for (var k = 0; k < groups[_group].length; ++k) {\n            expandedGroups.push(groups[_group][k]);\n          }\n        }\n\n        graph[node] = expandedGroups;\n      } // Merge intermediary graph using graphAfters into final graph\n\n\n      var afterNodes = Object.keys(graphAfters);\n\n      for (var _i3 = 0; _i3 < afterNodes.length; ++_i3) {\n        var _group2 = afterNodes[_i3];\n\n        if (groups[_group2]) {\n          for (var _j2 = 0; _j2 < groups[_group2].length; ++_j2) {\n            var _node = groups[_group2][_j2];\n            graph[_node] = graph[_node].concat(graphAfters[_group2]);\n          }\n        }\n      } // Compile ancestors\n\n\n      var children;\n      var ancestors = {};\n      graphNodes = Object.keys(graph);\n\n      for (var _i4 = 0; _i4 < graphNodes.length; ++_i4) {\n        var _node2 = graphNodes[_i4];\n        children = graph[_node2];\n\n        for (var _j3 = 0; _j3 < children.length; ++_j3) {\n          ancestors[children[_j3]] = (ancestors[children[_j3]] || []).concat(_node2);\n        }\n      } // Topo sort\n\n\n      var visited = {};\n      var sorted = [];\n\n      for (var _i5 = 0; _i5 < this._items.length; ++_i5) {\n        // Really looping thru item.seq values out of order\n        var next = _i5;\n\n        if (ancestors[_i5]) {\n          next = null;\n\n          for (var _j4 = 0; _j4 < this._items.length; ++_j4) {\n            // As above, these are item.seq values\n            if (visited[_j4] === true) {\n              continue;\n            }\n\n            if (!ancestors[_j4]) {\n              ancestors[_j4] = [];\n            }\n\n            var shouldSeeCount = ancestors[_j4].length;\n            var seenCount = 0;\n\n            for (var _k = 0; _k < shouldSeeCount; ++_k) {\n              if (visited[ancestors[_j4][_k]]) {\n                ++seenCount;\n              }\n            }\n\n            if (seenCount === shouldSeeCount) {\n              next = _j4;\n              break;\n            }\n          }\n        }\n\n        if (next !== null) {\n          visited[next] = true;\n          sorted.push(next);\n        }\n      }\n\n      if (sorted.length !== this._items.length) {\n        return new Error('Invalid dependencies');\n      }\n\n      var seqIndex = {};\n\n      for (var _i6 = 0; _i6 < this._items.length; ++_i6) {\n        var _item = this._items[_i6];\n        seqIndex[_item.seq] = _item;\n      }\n\n      var sortedNodes = [];\n      this._items = sorted.map(function (value) {\n        var sortedItem = seqIndex[value];\n        sortedNodes.push(sortedItem.node);\n        return sortedItem;\n      });\n      this.nodes = sortedNodes;\n    }\n  }]);\n\n  return Topo;\n}();\n\ninternals.mergeSort = function (a, b) {\n  return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;\n};","map":null,"metadata":{},"sourceType":"script"}