{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/miladarif/Desktop/React/movie-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/miladarif/Desktop/React/movie-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/miladarif/Desktop/React/movie-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/miladarif/Desktop/React/movie-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/miladarif/Desktop/React/movie-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar Hoek = require('@hapi/hoek');\n\nvar Any = require('../any');\n\nvar Ref = require('../../ref');\n\nvar internals = {\n  precisionRx: /(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/,\n  normalizeExponent: function normalizeExponent(str) {\n    return str.replace(/\\.?0+e/, 'e').replace(/e\\+/, 'e').replace(/^\\+/, '').replace(/^(-?)0+([1-9])/, '$1$2');\n  },\n  normalizeDecimal: function normalizeDecimal(str) {\n    str = str.replace(/^\\+/, '').replace(/\\.0+$/, '').replace(/^(-?)0+([1-9])/, '$1$2');\n\n    if (str.includes('.') && str.endsWith('0')) {\n      str = str.replace(/0+$/, '');\n    }\n\n    return str;\n  }\n};\n\ninternals.Number =\n/*#__PURE__*/\nfunction (_Any) {\n  _inherits(_class, _Any);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this));\n    _this._type = 'number';\n    _this._flags.unsafe = false;\n\n    _this._invalids.add(Infinity);\n\n    _this._invalids.add(-Infinity);\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      var result = {\n        errors: null,\n        value: value\n      };\n\n      if (typeof value === 'string' && options.convert) {\n        var matches = value.match(/^\\s*[+-]?\\d+(?:\\.\\d+)?(?:e([+-]?\\d+))?\\s*$/i);\n\n        if (matches) {\n          value = value.trim();\n          result.value = parseFloat(value);\n\n          if (!this._flags.unsafe) {\n            if (value.includes('e')) {\n              if (internals.normalizeExponent(\"\".concat(result.value / Math.pow(10, matches[1]), \"e\").concat(matches[1])) !== internals.normalizeExponent(value)) {\n                result.errors = this.createError('number.unsafe', {\n                  value: value\n                }, state, options);\n                return result;\n              }\n            } else {\n              if (result.value.toString() !== internals.normalizeDecimal(value)) {\n                result.errors = this.createError('number.unsafe', {\n                  value: value\n                }, state, options);\n                return result;\n              }\n            }\n          }\n        }\n      }\n\n      var isNumber = typeof result.value === 'number' && !isNaN(result.value);\n\n      if (options.convert && 'precision' in this._flags && isNumber) {\n        // This is conceptually equivalent to using toFixed but it should be much faster\n        var precision = Math.pow(10, this._flags.precision);\n        result.value = Math.round(result.value * precision) / precision;\n      }\n\n      if (isNumber) {\n        if (!this._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {\n          result.errors = this.createError('number.unsafe', {\n            value: value\n          }, state, options);\n        }\n      } else {\n        result.errors = this.createError('number.base', {\n          value: value\n        }, state, options);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"multiple\",\n    value: function multiple(base) {\n      var isRef = Ref.isRef(base);\n\n      if (!isRef) {\n        Hoek.assert(typeof base === 'number' && isFinite(base), 'multiple must be a number');\n        Hoek.assert(base > 0, 'multiple must be greater than 0');\n      }\n\n      return this._test('multiple', base, function (value, state, options) {\n        var divisor = isRef ? base(state.reference || state.parent, options) : base;\n\n        if (isRef && (typeof divisor !== 'number' || !isFinite(divisor))) {\n          return this.createError('number.ref', {\n            ref: base.key\n          }, state, options);\n        }\n\n        if (value % divisor === 0) {\n          return value;\n        }\n\n        return this.createError('number.multiple', {\n          multiple: base,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"integer\",\n    value: function integer() {\n      return this._test('integer', undefined, function (value, state, options) {\n        return Math.trunc(value) - value === 0 ? value : this.createError('number.integer', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"unsafe\",\n    value: function unsafe() {\n      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      Hoek.assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n\n      if (this._flags.unsafe === enabled) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.unsafe = enabled;\n      return obj;\n    }\n  }, {\n    key: \"negative\",\n    value: function negative() {\n      return this._test('negative', undefined, function (value, state, options) {\n        if (value < 0) {\n          return value;\n        }\n\n        return this.createError('number.negative', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"positive\",\n    value: function positive() {\n      return this._test('positive', undefined, function (value, state, options) {\n        if (value > 0) {\n          return value;\n        }\n\n        return this.createError('number.positive', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"precision\",\n    value: function precision(limit) {\n      Hoek.assert(Number.isSafeInteger(limit), 'limit must be an integer');\n      Hoek.assert(!('precision' in this._flags), 'precision already set');\n\n      var obj = this._test('precision', limit, function (value, state, options) {\n        var places = value.toString().match(internals.precisionRx);\n        var decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);\n\n        if (decimals <= limit) {\n          return value;\n        }\n\n        return this.createError('number.precision', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n\n      obj._flags.precision = limit;\n      return obj;\n    }\n  }, {\n    key: \"port\",\n    value: function port() {\n      return this._test('port', undefined, function (value, state, options) {\n        if (!Number.isSafeInteger(value) || value < 0 || value > 65535) {\n          return this.createError('number.port', {\n            value: value\n          }, state, options);\n        }\n\n        return value;\n      });\n    }\n  }]);\n\n  return _class;\n}(Any);\n\ninternals.compare = function (type, compare) {\n  return function (limit) {\n    var isRef = Ref.isRef(limit);\n    var isNumber = typeof limit === 'number' && !isNaN(limit);\n    Hoek.assert(isNumber || isRef, 'limit must be a number or reference');\n    return this._test(type, limit, function (value, state, options) {\n      var compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n\n        if (!(typeof compareTo === 'number' && !isNaN(compareTo))) {\n          return this.createError('number.ref', {\n            ref: limit.key\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (compare(value, compareTo)) {\n        return value;\n      }\n\n      return this.createError('number.' + type, {\n        limit: compareTo,\n        value: value\n      }, state, options);\n    });\n  };\n};\n\ninternals.Number.prototype.min = internals.compare('min', function (value, limit) {\n  return value >= limit;\n});\ninternals.Number.prototype.max = internals.compare('max', function (value, limit) {\n  return value <= limit;\n});\ninternals.Number.prototype.greater = internals.compare('greater', function (value, limit) {\n  return value > limit;\n});\ninternals.Number.prototype.less = internals.compare('less', function (value, limit) {\n  return value < limit;\n});\nmodule.exports = new internals.Number();","map":null,"metadata":{},"sourceType":"script"}