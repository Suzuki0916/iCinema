{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/miladarif/Desktop/React/movie-app/client/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/miladarif/Desktop/React/movie-app/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/miladarif/Desktop/React/movie-app/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/miladarif/Desktop/React/movie-app/client/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/miladarif/Desktop/React/movie-app/client/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/Users/miladarif/Desktop/React/movie-app/client/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/Users/miladarif/Desktop/React/movie-app/client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar Hoek = require('@hapi/hoek');\n\nvar Any = require('../any');\n\nvar Cast = require('../../cast');\n\nvar Ref = require('../../ref');\n\nvar internals = {};\n\ninternals.Alternatives =\n/*#__PURE__*/\nfunction (_Any) {\n  _inherits(_class, _Any);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this));\n    _this._type = 'alternatives';\n\n    _this._invalids.remove(null);\n\n    _this._inner.matches = [];\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"_init\",\n    value: function _init() {\n      return arguments.length ? this.try.apply(this, arguments) : this;\n    }\n  }, {\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      var errors = [];\n      var il = this._inner.matches.length;\n      var baseType = this._baseType;\n\n      for (var i = 0; i < il; ++i) {\n        var item = this._inner.matches[i];\n\n        if (!item.schema) {\n          var schema = item.peek || item.is;\n          var input = item.is ? item.ref(state.reference || state.parent, options) : value;\n\n          var failed = schema._validate(input, null, options, state.parent).errors;\n\n          if (failed) {\n            if (item.otherwise) {\n              return item.otherwise._validate(value, state, options);\n            }\n          } else if (item.then) {\n            return item.then._validate(value, state, options);\n          }\n\n          if (i === il - 1 && baseType) {\n            return baseType._validate(value, state, options);\n          }\n\n          continue;\n        }\n\n        var result = item.schema._validate(value, state, options);\n\n        if (!result.errors) {\n          // Found a valid match\n          return result;\n        }\n\n        errors.push.apply(errors, _toConsumableArray(result.errors));\n      }\n\n      if (errors.length) {\n        return {\n          errors: this.createError('alternatives.child', {\n            reason: errors\n          }, state, options)\n        };\n      }\n\n      return {\n        errors: this.createError('alternatives.base', null, state, options)\n      };\n    }\n  }, {\n    key: \"try\",\n    value: function _try() {\n      for (var _len = arguments.length, schemas = new Array(_len), _key = 0; _key < _len; _key++) {\n        schemas[_key] = arguments[_key];\n      }\n\n      schemas = Hoek.flatten(schemas);\n      Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n      var obj = this.clone();\n\n      for (var i = 0; i < schemas.length; ++i) {\n        var cast = Cast.schema(this._currentJoi, schemas[i]);\n\n        if (cast._refs.length) {\n          var _obj$_refs;\n\n          (_obj$_refs = obj._refs).push.apply(_obj$_refs, _toConsumableArray(cast._refs));\n        }\n\n        obj._inner.matches.push({\n          schema: cast\n        });\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"when\",\n    value: function when(condition, options) {\n      var schemaCondition = false;\n      Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);\n      Hoek.assert(options, 'Missing options');\n      Hoek.assert(typeof options === 'object', 'Invalid options');\n\n      if (schemaCondition) {\n        Hoek.assert(!options.hasOwnProperty('is'), '\"is\" can not be used with a schema condition');\n      } else {\n        Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n      }\n\n      Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n      var obj = this.clone();\n      var is;\n\n      if (!schemaCondition) {\n        is = Cast.schema(this._currentJoi, options.is);\n\n        if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n          // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n          is = is.required();\n        }\n      }\n\n      var item = {\n        ref: schemaCondition ? null : Cast.ref(condition),\n        peek: schemaCondition ? condition : null,\n        is: is,\n        then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,\n        otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined\n      };\n\n      if (obj._baseType) {\n        item.then = item.then && obj._baseType.concat(item.then);\n        item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);\n      }\n\n      if (!schemaCondition) {\n        var _obj$_refs2;\n\n        Ref.push(obj._refs, item.ref);\n\n        (_obj$_refs2 = obj._refs).push.apply(_obj$_refs2, _toConsumableArray(item.is._refs));\n      }\n\n      if (item.then && item.then._refs.length) {\n        var _obj$_refs3;\n\n        (_obj$_refs3 = obj._refs).push.apply(_obj$_refs3, _toConsumableArray(item.then._refs));\n      }\n\n      if (item.otherwise && item.otherwise._refs.length) {\n        var _obj$_refs4;\n\n        (_obj$_refs4 = obj._refs).push.apply(_obj$_refs4, _toConsumableArray(item.otherwise._refs));\n      }\n\n      obj._inner.matches.push(item);\n\n      return obj;\n    }\n  }, {\n    key: \"label\",\n    value: function label(name) {\n      var obj = _get(_getPrototypeOf(_class.prototype), \"label\", this).call(this, name);\n\n      obj._inner.matches = obj._inner.matches.map(function (match) {\n        if (match.schema) {\n          return {\n            schema: match.schema.label(name)\n          };\n        }\n\n        match = Object.assign({}, match);\n\n        if (match.then) {\n          match.then = match.then.label(name);\n        }\n\n        if (match.otherwise) {\n          match.otherwise = match.otherwise.label(name);\n        }\n\n        return match;\n      });\n      return obj;\n    }\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      var description = _get(_getPrototypeOf(_class.prototype), \"describe\", this).call(this);\n\n      var alternatives = [];\n\n      for (var i = 0; i < this._inner.matches.length; ++i) {\n        var item = this._inner.matches[i];\n\n        if (item.schema) {\n          // try()\n          alternatives.push(item.schema.describe());\n        } else {\n          // when()\n          var when = item.is ? {\n            ref: item.ref.toString(),\n            is: item.is.describe()\n          } : {\n            peek: item.peek.describe()\n          };\n\n          if (item.then) {\n            when.then = item.then.describe();\n          }\n\n          if (item.otherwise) {\n            when.otherwise = item.otherwise.describe();\n          }\n\n          alternatives.push(when);\n        }\n      }\n\n      description.alternatives = alternatives;\n      return description;\n    }\n  }]);\n\n  return _class;\n}(Any);\n\nmodule.exports = new internals.Alternatives();","map":null,"metadata":{},"sourceType":"script"}