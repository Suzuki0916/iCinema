{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nvar CastError = require('../error/cast');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar ObjectExpectedError = require('../error/objectExpected');\n\nvar SchemaType = require('../schematype');\n\nvar $exists = require('./operators/exists');\n\nvar castToNumber = require('./operators/helpers').castToNumber;\n\nvar discriminator = require('../helpers/model/discriminator');\n\nvar geospatial = require('./operators/geospatial');\n\nvar get = require('../helpers/get');\n\nvar getDiscriminatorByValue = require('../queryhelpers').getDiscriminatorByValue;\n\nvar internalToObjectOptions = require('../options').internalToObjectOptions;\n\nvar Subdocument;\nmodule.exports = Embedded;\n/**\n * Sub-schema schematype constructor\n *\n * @param {Schema} schema\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction Embedded(schema, path, options) {\n  this.caster = _createConstructor(schema);\n  this.caster.path = path;\n  this.caster.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n/*!\n * ignore\n */\n\n\nEmbedded.prototype = Object.create(SchemaType.prototype);\nEmbedded.prototype.constructor = Embedded;\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema) {\n  // lazy load\n  Subdocument || (Subdocument = require('../types/subdocument'));\n\n  var _embedded = function SingleNested(value, path, parent) {\n    var _this = this;\n\n    this.$parent = parent;\n    Subdocument.apply(this, arguments);\n    this.$session(this.ownerDocument().$session());\n\n    if (parent) {\n      parent.on('save', function () {\n        _this.emit('save', _this);\n\n        _this.constructor.emit('save', _this);\n      });\n      parent.on('isNew', function (val) {\n        _this.isNew = val;\n\n        _this.emit('isNew', val);\n\n        _this.constructor.emit('isNew', val);\n      });\n    }\n  };\n\n  _embedded.prototype = Object.create(Subdocument.prototype);\n\n  _embedded.prototype.$__setSchema(schema);\n\n  _embedded.prototype.constructor = _embedded;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n\n  _embedded.prototype.toBSON = function () {\n    return this.toObject(internalToObjectOptions);\n  }; // apply methods\n\n\n  for (var i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  } // apply statics\n\n\n  for (var _i in schema.statics) {\n    _embedded[_i] = schema.statics[_i];\n  }\n\n  for (var _i2 in EventEmitter.prototype) {\n    _embedded[_i2] = EventEmitter.prototype[_i2];\n  }\n\n  return _embedded;\n}\n/*!\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\n\nEmbedded.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {\n  return {\n    $geometry: this.castForQuery(val.$geometry)\n  };\n};\n/*!\n * ignore\n */\n\n\nEmbedded.prototype.$conditionalHandlers.$near = Embedded.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\nEmbedded.prototype.$conditionalHandlers.$within = Embedded.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\nEmbedded.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;\nEmbedded.prototype.$conditionalHandlers.$minDistance = castToNumber;\nEmbedded.prototype.$conditionalHandlers.$maxDistance = castToNumber;\nEmbedded.prototype.$conditionalHandlers.$exists = $exists;\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nEmbedded.prototype.cast = function (val, doc, init, priorVal) {\n  if (val && val.$isSingleNested) {\n    return val;\n  }\n\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n\n  var Constructor = this.caster;\n  var discriminatorKey = Constructor.schema.options.discriminatorKey;\n\n  if (val != null && Constructor.discriminators && typeof val[discriminatorKey] === 'string') {\n    if (Constructor.discriminators[val[discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[discriminatorKey]];\n    } else {\n      var constructorByValue = getDiscriminatorByValue(Constructor, val[discriminatorKey]);\n\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  var subdoc; // Only pull relevant selected paths and pull out the base path\n\n  var parentSelected = get(doc, '$__.selected', {});\n  var path = this.path;\n  var selected = Object.keys(parentSelected).reduce(function (obj, key) {\n    if (key.startsWith(path + '.')) {\n      obj[key.substr(path.length + 1)] = parentSelected[key];\n    }\n\n    return obj;\n  }, {});\n\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc);\n    subdoc.init(val);\n  } else {\n    if (Object.keys(val).length === 0) {\n      return new Constructor({}, selected, doc);\n    }\n\n    return new Constructor(val, selected, doc, undefined, {\n      priorDoc: priorVal\n    });\n  }\n\n  return subdoc;\n};\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\n\nEmbedded.prototype.castForQuery = function ($conditional, val) {\n  var handler;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n\n    return handler.call(this, val);\n  }\n\n  val = $conditional;\n\n  if (val == null) {\n    return val;\n  }\n\n  if (this.options.runSetters) {\n    val = this._applySetters(val);\n  }\n\n  var Constructor = this.caster;\n  var discriminatorKey = Constructor.schema.options.discriminatorKey;\n\n  if (val != null && Constructor.discriminators && typeof val[discriminatorKey] === 'string') {\n    if (Constructor.discriminators[val[discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[discriminatorKey]];\n    } else {\n      var constructorByValue = getDiscriminatorByValue(Constructor, val[discriminatorKey]);\n\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  try {\n    val = new Constructor(val);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error);\n    }\n\n    throw error;\n  }\n\n  return val;\n};\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\n\nEmbedded.prototype.doValidate = function (value, fn, scope, options) {\n  var Constructor = this.caster;\n  var discriminatorKey = Constructor.schema.options.discriminatorKey;\n\n  if (value != null && Constructor.discriminators && typeof value[discriminatorKey] === 'string') {\n    if (Constructor.discriminators[value[discriminatorKey]]) {\n      Constructor = Constructor.discriminators[value[discriminatorKey]];\n    } else {\n      var constructorByValue = getDiscriminatorByValue(Constructor, value[discriminatorKey]);\n\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  if (options && options.skipSchemaValidators) {\n    if (!(value instanceof Constructor)) {\n      value = new Constructor(value, null, scope);\n    }\n\n    return value.validate(fn);\n  }\n\n  SchemaType.prototype.doValidate.call(this, value, function (error) {\n    if (error) {\n      return fn(error);\n    }\n\n    if (!value) {\n      return fn(null);\n    }\n\n    value.validate(fn);\n  }, scope);\n};\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\n\nEmbedded.prototype.doValidateSync = function (value, scope, options) {\n  if (!options || !options.skipSchemaValidators) {\n    var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n\n  if (!value) {\n    return;\n  }\n\n  return value.validateSync();\n};\n/**\n * Adds a discriminator to this property\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @api public\n */\n\n\nEmbedded.prototype.discriminator = function (name, schema) {\n  discriminator(this.caster, name, schema);\n  this.caster.discriminators[name] = _createConstructor(schema);\n  return this.caster.discriminators[name];\n};\n/*!\n * ignore\n */\n\n\nEmbedded.prototype.clone = function () {\n  var options = Object.assign({}, this.options, {\n    validators: this.validators\n  });\n  return new this.constructor(this.schema, this.path, options);\n};","map":null,"metadata":{},"sourceType":"script"}