{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/miladarif/Desktop/React/movie-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/miladarif/Desktop/React/movie-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/miladarif/Desktop/React/movie-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Hoek = require('@hapi/hoek');\n\nvar Settings = require('./settings');\n\nvar Ref = require('../../ref');\n\nvar Errors = require('../../errors');\n\nvar State = require('../state');\n\nvar Symbols = require('../symbols');\n\nvar Alternatives = null; // Delay-loaded to prevent circular dependencies\n\nvar Cast = null;\nvar Schemas = null;\nvar internals = {\n  Set: require('../../set')\n};\ninternals.defaults = {\n  abortEarly: true,\n  convert: true,\n  allowUnknown: false,\n  skipFunctions: false,\n  stripUnknown: false,\n  language: {},\n  presence: 'optional',\n  strip: false,\n  noDefaults: false,\n  escapeHtml: false // context: null\n\n};\n\nmodule.exports = internals.Any =\n/*#__PURE__*/\nfunction () {\n  function _class() {\n    _classCallCheck(this, _class);\n\n    Cast = Cast || require('../../cast');\n    this.isJoi = true;\n    this._type = 'any';\n    this._settings = null;\n    this._valids = new internals.Set();\n    this._invalids = new internals.Set();\n    this._tests = [];\n    this._refs = [];\n    this._flags = {\n      /*\n       presence: 'optional',                   // optional, required, forbidden, ignore\n       allowOnly: false,\n       allowUnknown: undefined,\n       default: undefined,\n       forbidden: false,\n       encoding: undefined,\n       insensitive: false,\n       trim: false,\n       normalize: undefined,                   // NFC, NFD, NFKC, NFKD\n       case: undefined,                        // upper, lower\n       empty: undefined,\n       func: false,\n       raw: false\n       */\n    };\n    this._description = null;\n    this._unit = null;\n    this._notes = [];\n    this._tags = [];\n    this._examples = [];\n    this._meta = [];\n    this._inner = {}; // Hash of arrays of immutable objects\n  }\n\n  _createClass(_class, [{\n    key: \"_init\",\n    value: function _init() {\n      return this;\n    }\n  }, {\n    key: \"createError\",\n    value: function createError(type, context, state, options) {\n      var flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this._flags;\n      return Errors.create(type, context, state, options, flags);\n    }\n  }, {\n    key: \"createOverrideError\",\n    value: function createOverrideError(type, context, state, options, message, template) {\n      return Errors.create(type, context, state, options, this._flags, message, template);\n    }\n  }, {\n    key: \"checkOptions\",\n    value: function checkOptions(options) {\n      Schemas = Schemas || require('../../schemas');\n      var result = Schemas.options.validate(options);\n\n      if (result.error) {\n        throw new Error(result.error.details[0].message);\n      }\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var obj = Object.create(Object.getPrototypeOf(this));\n      obj.isJoi = true;\n      obj._currentJoi = this._currentJoi;\n      obj._type = this._type;\n      obj._settings = this._settings;\n      obj._baseType = this._baseType;\n      obj._valids = this._valids.slice();\n      obj._invalids = this._invalids.slice();\n      obj._tests = this._tests.slice();\n      obj._refs = this._refs.slice();\n      obj._flags = Hoek.clone(this._flags);\n      obj._description = this._description;\n      obj._unit = this._unit;\n      obj._notes = this._notes.slice();\n      obj._tags = this._tags.slice();\n      obj._examples = this._examples.slice();\n      obj._meta = this._meta.slice();\n      obj._inner = {};\n      var inners = Object.keys(this._inner);\n\n      for (var i = 0; i < inners.length; ++i) {\n        var key = inners[i];\n        obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(schema) {\n      var _obj$_tests, _obj$_refs, _obj$_notes, _obj$_tags, _obj$_examples, _obj$_meta;\n\n      Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\n      Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n      var obj = this.clone();\n\n      if (this._type === 'any' && schema._type !== 'any') {\n        // Reset values as if we were \"this\"\n        var tmpObj = schema.clone();\n        var keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit', '_notes', '_tags', '_examples', '_meta', '_inner'];\n\n        for (var i = 0; i < keysToRestore.length; ++i) {\n          tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n        }\n\n        obj = tmpObj;\n      }\n\n      obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\n\n      obj._valids.merge(schema._valids, schema._invalids);\n\n      obj._invalids.merge(schema._invalids, schema._valids);\n\n      (_obj$_tests = obj._tests).push.apply(_obj$_tests, _toConsumableArray(schema._tests));\n\n      (_obj$_refs = obj._refs).push.apply(_obj$_refs, _toConsumableArray(schema._refs));\n\n      if (obj._flags.empty && schema._flags.empty) {\n        obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\n        var flags = Object.assign({}, schema._flags);\n        delete flags.empty;\n        Hoek.merge(obj._flags, flags);\n      } else if (schema._flags.empty) {\n        obj._flags.empty = schema._flags.empty;\n\n        var _flags = Object.assign({}, schema._flags);\n\n        delete _flags.empty;\n        Hoek.merge(obj._flags, _flags);\n      } else {\n        Hoek.merge(obj._flags, schema._flags);\n      }\n\n      obj._description = schema._description || obj._description;\n      obj._unit = schema._unit || obj._unit;\n\n      (_obj$_notes = obj._notes).push.apply(_obj$_notes, _toConsumableArray(schema._notes));\n\n      (_obj$_tags = obj._tags).push.apply(_obj$_tags, _toConsumableArray(schema._tags));\n\n      (_obj$_examples = obj._examples).push.apply(_obj$_examples, _toConsumableArray(schema._examples));\n\n      (_obj$_meta = obj._meta).push.apply(_obj$_meta, _toConsumableArray(schema._meta));\n\n      var inners = Object.keys(schema._inner);\n      var isObject = obj._type === 'object';\n\n      for (var _i = 0; _i < inners.length; ++_i) {\n        var key = inners[_i];\n        var source = schema._inner[key];\n\n        if (source) {\n          var target = obj._inner[key];\n\n          if (target) {\n            if (isObject && key === 'children') {\n              var keys = {};\n\n              for (var j = 0; j < target.length; ++j) {\n                keys[target[j].key] = j;\n              }\n\n              for (var _j = 0; _j < source.length; ++_j) {\n                var sourceKey = source[_j].key;\n\n                if (keys[sourceKey] >= 0) {\n                  target[keys[sourceKey]] = {\n                    key: sourceKey,\n                    schema: target[keys[sourceKey]].schema.concat(source[_j].schema)\n                  };\n                } else {\n                  target.push(source[_j]);\n                }\n              }\n            } else {\n              obj._inner[key] = obj._inner[key].concat(source);\n            }\n          } else {\n            obj._inner[key] = source.slice();\n          }\n        }\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"_test\",\n    value: function _test(name, arg, func, options) {\n      var obj = this.clone();\n\n      obj._tests.push({\n        func: func,\n        name: name,\n        arg: arg,\n        options: options\n      });\n\n      return obj;\n    }\n  }, {\n    key: \"_testUnique\",\n    value: function _testUnique(name, arg, func, options) {\n      var obj = this.clone();\n      obj._tests = obj._tests.filter(function (test) {\n        return test.name !== name;\n      });\n\n      obj._tests.push({\n        func: func,\n        name: name,\n        arg: arg,\n        options: options\n      });\n\n      return obj;\n    }\n  }, {\n    key: \"options\",\n    value: function options(_options) {\n      Hoek.assert(!_options.context, 'Cannot override context');\n      this.checkOptions(_options);\n      var obj = this.clone();\n      obj._settings = Settings.concat(obj._settings, _options);\n      return obj;\n    }\n  }, {\n    key: \"strict\",\n    value: function strict(isStrict) {\n      var obj = this.clone();\n      var convert = isStrict === undefined ? false : !isStrict;\n      obj._settings = Settings.concat(obj._settings, {\n        convert: convert\n      });\n      return obj;\n    }\n  }, {\n    key: \"raw\",\n    value: function raw(isRaw) {\n      var value = isRaw === undefined ? true : isRaw;\n\n      if (this._flags.raw === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.raw = value;\n      return obj;\n    }\n  }, {\n    key: \"error\",\n    value: function error(err) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        self: false\n      };\n      Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\n      var unknownKeys = Object.keys(options).filter(function (k) {\n        return !['self'].includes(k);\n      });\n      Hoek.assert(unknownKeys.length === 0, \"Options \".concat(unknownKeys, \" are unknown\"));\n      var obj = this.clone();\n      obj._flags.error = err;\n\n      if (options.self) {\n        obj._flags.selfError = true;\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"allow\",\n    value: function allow() {\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n\n      var obj = this.clone();\n      values = Hoek.flatten(values);\n\n      for (var i = 0; i < values.length; ++i) {\n        var value = values[i];\n        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n        obj._invalids.remove(value);\n\n        obj._valids.add(value, obj._refs);\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"valid\",\n    value: function valid() {\n      var obj = this.allow.apply(this, arguments);\n      obj._flags.allowOnly = true;\n      return obj;\n    }\n  }, {\n    key: \"invalid\",\n    value: function invalid() {\n      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        values[_key2] = arguments[_key2];\n      }\n\n      var obj = this.clone();\n      values = Hoek.flatten(values);\n\n      for (var i = 0; i < values.length; ++i) {\n        var value = values[i];\n        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n        obj._valids.remove(value);\n\n        obj._invalids.add(value, obj._refs);\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"required\",\n    value: function required() {\n      if (this._flags.presence === 'required') {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.presence = 'required';\n      return obj;\n    }\n  }, {\n    key: \"optional\",\n    value: function optional() {\n      if (this._flags.presence === 'optional') {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.presence = 'optional';\n      return obj;\n    }\n  }, {\n    key: \"forbidden\",\n    value: function forbidden() {\n      if (this._flags.presence === 'forbidden') {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.presence = 'forbidden';\n      return obj;\n    }\n  }, {\n    key: \"strip\",\n    value: function strip() {\n      if (this._flags.strip) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.strip = true;\n      return obj;\n    }\n  }, {\n    key: \"applyFunctionToChildren\",\n    value: function applyFunctionToChildren(children, fn) {\n      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var root = arguments.length > 3 ? arguments[3] : undefined;\n      children = [].concat(children);\n\n      if (children.length !== 1 || children[0] !== '') {\n        root = root ? root + '.' : '';\n        var extraChildren = (children[0] === '' ? children.slice(1) : children).map(function (child) {\n          return root + child;\n        });\n        throw new Error('unknown key(s) ' + extraChildren.join(', '));\n      }\n\n      return this[fn].apply(this, _toConsumableArray(args));\n    }\n  }, {\n    key: \"default\",\n    value: function _default(value, description) {\n      if (typeof value === 'function' && !Ref.isRef(value)) {\n        if (!value.description && description) {\n          value.description = description;\n        }\n\n        if (!this._flags.func) {\n          Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n        }\n      }\n\n      var obj = this.clone();\n      obj._flags.default = value;\n      Ref.push(obj._refs, value);\n      return obj;\n    }\n  }, {\n    key: \"empty\",\n    value: function empty(schema) {\n      var obj = this.clone();\n\n      if (schema === undefined) {\n        delete obj._flags.empty;\n      } else {\n        obj._flags.empty = Cast.schema(this._currentJoi, schema);\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"when\",\n    value: function when(condition, options) {\n      Hoek.assert(options && typeof options === 'object', 'Invalid options');\n      Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n      var then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\n      var otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\n      Alternatives = Alternatives || require('../alternatives');\n      var alternativeOptions = {\n        then: then,\n        otherwise: otherwise\n      };\n\n      if (Object.prototype.hasOwnProperty.call(options, 'is')) {\n        alternativeOptions.is = options.is;\n      }\n\n      var obj = Alternatives.when(condition, alternativeOptions);\n      obj._flags.presence = 'ignore';\n      obj._baseType = this;\n      return obj;\n    }\n  }, {\n    key: \"description\",\n    value: function description(desc) {\n      Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n      var obj = this.clone();\n      obj._description = desc;\n      return obj;\n    }\n  }, {\n    key: \"notes\",\n    value: function notes(_notes) {\n      Hoek.assert(_notes && (typeof _notes === 'string' || Array.isArray(_notes)), 'Notes must be a non-empty string or array');\n      var obj = this.clone();\n      obj._notes = obj._notes.concat(_notes);\n      return obj;\n    }\n  }, {\n    key: \"tags\",\n    value: function tags(_tags) {\n      Hoek.assert(_tags && (typeof _tags === 'string' || Array.isArray(_tags)), 'Tags must be a non-empty string or array');\n      var obj = this.clone();\n      obj._tags = obj._tags.concat(_tags);\n      return obj;\n    }\n  }, {\n    key: \"meta\",\n    value: function meta(_meta) {\n      Hoek.assert(_meta !== undefined, 'Meta cannot be undefined');\n      var obj = this.clone();\n      obj._meta = obj._meta.concat(_meta);\n      return obj;\n    }\n  }, {\n    key: \"example\",\n    value: function example() {\n      Hoek.assert(arguments.length > 0, 'Missing examples');\n      var processed = [];\n\n      for (var i = 0; i < arguments.length; ++i) {\n        var example = [].concat(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n        Hoek.assert(example.length <= 2, \"Bad example format at index \".concat(i));\n        var value = example[0];\n        var options = example[1];\n\n        if (options !== undefined) {\n          Hoek.assert(options && typeof options === 'object', \"Options for example at index \".concat(i, \" must be an object\"));\n          var unknownOptions = Object.keys(options).filter(function (option) {\n            return !['parent', 'context'].includes(option);\n          });\n          Hoek.assert(unknownOptions.length === 0, \"Unknown example options \".concat(unknownOptions, \" at index \").concat(i));\n        } else {\n          options = {};\n        }\n\n        var localState = new State('', [], options.parent || null);\n\n        var result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? {\n          context: options.context\n        } : null));\n\n        Hoek.assert(!result.errors, \"Bad example at index \".concat(i, \":\"), result.errors && Errors.process(result.errors, value));\n        var ex = {\n          value: value\n        };\n\n        if (Object.keys(options).length) {\n          ex.options = options;\n        }\n\n        processed.push(ex);\n      }\n\n      var obj = this.clone();\n      obj._examples = processed;\n      return obj;\n    }\n  }, {\n    key: \"unit\",\n    value: function unit(name) {\n      Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n      var obj = this.clone();\n      obj._unit = name;\n      return obj;\n    }\n  }, {\n    key: \"_prepareEmptyValue\",\n    value: function _prepareEmptyValue(value) {\n      if (typeof value === 'string' && this._flags.trim) {\n        return value.trim();\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_validate\",\n    value: function _validate(value, state, options, reference) {\n      var originalValue = value; // Setup state and settings\n\n      state = state || new State('', [], null, reference);\n\n      if (this._settings) {\n        var isDefaultOptions = options === internals.defaults;\n\n        if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\n          options = this._settings[Symbols.settingsCache];\n        } else {\n          options = Settings.concat(options, this._settings);\n\n          if (isDefaultOptions) {\n            this._settings[Symbols.settingsCache] = options;\n          }\n        }\n      }\n\n      var errors = [];\n\n      if (this._coerce) {\n        var coerced = this._coerce(value, state, options);\n\n        if (coerced.errors) {\n          value = coerced.value;\n          errors = errors.concat(coerced.errors);\n          return this._finalizeValue(value, originalValue, errors, state, options); // Coerced error always aborts early\n        }\n\n        value = coerced.value;\n      }\n\n      if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\n        value = undefined;\n      } // Check presence requirements\n\n\n      var presence = this._flags.presence || options.presence;\n\n      if (presence === 'optional') {\n        if (value === undefined) {\n          var isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n\n          if (isDeepDefault && this._type === 'object') {\n            value = {};\n          } else {\n            return this._finalizeValue(value, originalValue, errors, state, options);\n          }\n        }\n      } else if (presence === 'required' && value === undefined) {\n        errors.push(this.createError('any.required', null, state, options));\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      } else if (presence === 'forbidden') {\n        if (value === undefined) {\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n\n        errors.push(this.createError('any.unknown', null, state, options));\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      } // Check allowed and denied values using the original value\n\n\n      var match = this._valids.get(value, state, options, this._flags.insensitive);\n\n      if (match) {\n        if (options.convert) {\n          value = match.value;\n        }\n\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      }\n\n      if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n        errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {\n          value: value,\n          invalids: this._invalids.values({\n            stripUndefined: true\n          })\n        }, state, options));\n\n        if (options.abortEarly) {\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n      } // Convert value and validate type\n\n\n      if (this._base) {\n        var base = this._base(value, state, options);\n\n        if (base.errors) {\n          value = base.value;\n          errors = errors.concat(base.errors);\n          return this._finalizeValue(value, originalValue, errors, state, options); // Base error always aborts early\n        }\n\n        if (base.value !== value) {\n          value = base.value; // Check allowed and denied values using the converted value\n\n          match = this._valids.get(value, state, options, this._flags.insensitive);\n\n          if (match) {\n            value = match.value;\n            return this._finalizeValue(value, originalValue, errors, state, options);\n          }\n\n          if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {\n              value: value,\n              invalids: this._invalids.values({\n                stripUndefined: true\n              })\n            }, state, options));\n\n            if (options.abortEarly) {\n              return this._finalizeValue(value, originalValue, errors, state, options);\n            }\n          }\n        }\n      } // Required values did not match\n\n\n      if (this._flags.allowOnly) {\n        errors.push(this.createError('any.allowOnly', {\n          value: value,\n          valids: this._valids.values({\n            stripUndefined: true\n          })\n        }, state, options));\n\n        if (options.abortEarly) {\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n      } // Validate tests\n\n\n      for (var i = 0; i < this._tests.length; ++i) {\n        var test = this._tests[i];\n        var ret = test.func.call(this, value, state, options);\n\n        if (ret instanceof Errors.Err) {\n          errors.push(ret);\n\n          if (options.abortEarly) {\n            return this._finalizeValue(value, originalValue, errors, state, options);\n          }\n        } else {\n          value = ret;\n        }\n      }\n\n      return this._finalizeValue(value, originalValue, errors, state, options);\n    }\n  }, {\n    key: \"_finalizeValue\",\n    value: function _finalizeValue(value, originalValue, errors, state, options) {\n      var _this = this;\n\n      var finalValue;\n\n      if (value !== undefined) {\n        finalValue = this._flags.raw ? originalValue : value;\n      } else if (options.noDefaults) {\n        finalValue = value;\n      } else if (Ref.isRef(this._flags.default)) {\n        finalValue = this._flags.default(state.parent, options);\n      } else if (typeof this._flags.default === 'function' && !(this._flags.func && !this._flags.default.description)) {\n        var args;\n\n        if (state.parent !== null && this._flags.default.length > 0) {\n          args = [Hoek.clone(state.parent), options];\n        }\n\n        var defaultValue = internals._try(this._flags.default, args);\n\n        finalValue = defaultValue.value;\n\n        if (defaultValue.error) {\n          errors.push(this.createError('any.default', {\n            error: defaultValue.error\n          }, state, options));\n        }\n      } else {\n        finalValue = Hoek.clone(this._flags.default);\n      }\n\n      if (errors.length && typeof this._flags.error === 'function' && (!this._flags.selfError || errors.some(function (e) {\n        return state.path.length === e.path.length;\n      }))) {\n        var change = this._flags.error.call(this, errors);\n\n        if (typeof change === 'string') {\n          errors = [this.createOverrideError('override', {\n            reason: errors\n          }, state, options, change)];\n        } else {\n          errors = [].concat(change).map(function (err) {\n            return err instanceof Error ? err : _this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\n          });\n        }\n      }\n\n      return {\n        value: this._flags.strip ? undefined : finalValue,\n        finalValue: finalValue,\n        errors: errors.length ? errors : null\n      };\n    }\n  }, {\n    key: \"_validateWithOptions\",\n    value: function _validateWithOptions(value, options, callback) {\n      if (options) {\n        this.checkOptions(options);\n      }\n\n      var settings = Settings.concat(internals.defaults, options);\n\n      var result = this._validate(value, null, settings);\n\n      var errors = Errors.process(result.errors, value);\n\n      if (callback) {\n        return callback(errors, result.value);\n      }\n\n      return {\n        error: errors,\n        value: result.value,\n        then: function then(resolve, reject) {\n          if (errors) {\n            return Promise.reject(errors).catch(reject);\n          }\n\n          return Promise.resolve(result.value).then(resolve);\n        },\n        catch: function _catch(reject) {\n          if (errors) {\n            return Promise.reject(errors).catch(reject);\n          }\n\n          return Promise.resolve(result.value);\n        }\n      };\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value, options, callback) {\n      if (typeof options === 'function') {\n        return this._validateWithOptions(value, null, options);\n      }\n\n      return this._validateWithOptions(value, options, callback);\n    }\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      var _this2 = this;\n\n      var description = {\n        type: this._type\n      };\n      var flags = Object.keys(this._flags);\n\n      if (flags.length) {\n        if (['empty', 'default', 'lazy', 'label'].some(function (flag) {\n          return _this2._flags.hasOwnProperty(flag);\n        })) {\n          description.flags = {};\n\n          for (var i = 0; i < flags.length; ++i) {\n            var flag = flags[i];\n\n            if (flag === 'empty') {\n              description.flags[flag] = this._flags[flag].describe();\n            } else if (flag === 'default') {\n              if (Ref.isRef(this._flags[flag])) {\n                description.flags[flag] = this._flags[flag].toString();\n              } else if (typeof this._flags[flag] === 'function') {\n                description.flags[flag] = {\n                  description: this._flags[flag].description,\n                  function: this._flags[flag]\n                };\n              } else {\n                description.flags[flag] = this._flags[flag];\n              }\n            } else if (flag === 'lazy' || flag === 'label') {// We don't want it in the description\n            } else {\n              description.flags[flag] = this._flags[flag];\n            }\n          }\n        } else {\n          description.flags = this._flags;\n        }\n      }\n\n      if (this._settings) {\n        description.options = Hoek.clone(this._settings);\n      }\n\n      if (this._baseType) {\n        description.base = this._baseType.describe();\n      }\n\n      if (this._description) {\n        description.description = this._description;\n      }\n\n      if (this._notes.length) {\n        description.notes = this._notes;\n      }\n\n      if (this._tags.length) {\n        description.tags = this._tags;\n      }\n\n      if (this._meta.length) {\n        description.meta = this._meta;\n      }\n\n      if (this._examples.length) {\n        description.examples = this._examples;\n      }\n\n      if (this._unit) {\n        description.unit = this._unit;\n      }\n\n      var valids = this._valids.values();\n\n      if (valids.length) {\n        description.valids = valids.map(function (v) {\n          return Ref.isRef(v) ? v.toString() : v;\n        });\n      }\n\n      var invalids = this._invalids.values();\n\n      if (invalids.length) {\n        description.invalids = invalids.map(function (v) {\n          return Ref.isRef(v) ? v.toString() : v;\n        });\n      }\n\n      description.rules = [];\n\n      for (var _i2 = 0; _i2 < this._tests.length; ++_i2) {\n        var validator = this._tests[_i2];\n        var item = {\n          name: validator.name\n        };\n\n        if (validator.arg !== void 0) {\n          item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\n        }\n\n        var options = validator.options;\n\n        if (options) {\n          if (options.hasRef) {\n            item.arg = {};\n            var keys = Object.keys(validator.arg);\n\n            for (var j = 0; j < keys.length; ++j) {\n              var key = keys[j];\n              var value = validator.arg[key];\n              item.arg[key] = Ref.isRef(value) ? value.toString() : value;\n            }\n          }\n\n          if (typeof options.description === 'string') {\n            item.description = options.description;\n          } else if (typeof options.description === 'function') {\n            item.description = options.description(item.arg);\n          }\n        }\n\n        description.rules.push(item);\n      }\n\n      if (!description.rules.length) {\n        delete description.rules;\n      }\n\n      var label = this._getLabel();\n\n      if (label) {\n        description.label = label;\n      }\n\n      return description;\n    }\n  }, {\n    key: \"label\",\n    value: function label(name) {\n      Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n      var obj = this.clone();\n      obj._flags.label = name;\n      return obj;\n    }\n  }, {\n    key: \"_getLabel\",\n    value: function _getLabel(def) {\n      return this._flags.label || def;\n    }\n  }, {\n    key: \"schemaType\",\n    get: function get() {\n      return this._type;\n    }\n  }]);\n\n  return _class;\n}();\n\ninternals.Any.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects\n// Aliases\n\ninternals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;\ninternals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;\ninternals.Any.prototype.exist = internals.Any.prototype.required;\n\ninternals._try = function (fn) {\n  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var err;\n  var result;\n\n  try {\n    result = fn.apply(void 0, _toConsumableArray(args));\n  } catch (e) {\n    err = e;\n  }\n\n  return {\n    value: result,\n    error: err\n  };\n};","map":null,"metadata":{},"sourceType":"script"}